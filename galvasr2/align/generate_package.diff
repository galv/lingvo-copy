1,4d0
< #!/usr/bin/env python
< from __future__ import absolute_import, division, print_function
< 
< import argparse
6,7c2
< 
< from deepspeech_training.util.text import Alphabet, UTF8Alphabet
---
> import struct
10a6,39
> class Alphabet(object):
>     def __init__(self, config_file):
>         self._config_file = config_file
>         self._label_to_str = {}
>         self._str_to_label = {}
>         self._size = 0
>         if config_file:
>             with open(config_file, 'r', encoding='utf-8') as fin:
>                 for line in fin:
>                     if line[0:2] == '\\#':
>                         line = '#\n'
>                     elif line[0] == '#':
>                         continue
>                     self._label_to_str[self._size] = line[:-1] # remove the line ending
>                     self._str_to_label[line[:-1]] = self._size
>                     self._size += 1
> 
>     def serialize(self):
>         # Serialization format is a sequence of (key, value) pairs, where key is
>         # a uint16_t and value is a uint16_t length followed by `length` UTF-8
>         # encoded bytes with the label.
>         res = bytearray()
> 
>         # We start by writing the number of pairs in the buffer as uint16_t.
>         res += struct.pack('<H', self._size)
>         for key, value in self._label_to_str.items():
>             value = value.encode('utf-8')
>             # struct.pack only takes fixed length strings/buffers, so we have to
>             # construct the correct format string with the length of the encoded
>             # label.
>             res += struct.pack('<HH{}s'.format(len(value)), key, len(value), value)
>         return bytes(res)
> 
> 
21d49
<     vocab_looks_char_based = True
26,44c54,57
<                 if len(word) > 1:
<                     vocab_looks_char_based = False
<     print("{} unique words read from vocabulary file.".format(len(words)))
< 
<     cbm = "Looks" if vocab_looks_char_based else "Doesn't look"
<     print("{} like a character based model.".format(cbm))
< 
<     if force_utf8 != None:  # pylint: disable=singleton-comparison
<         use_utf8 = force_utf8.value
<     else:
<         use_utf8 = vocab_looks_char_based
<         print("Using detected UTF-8 mode: {}".format(use_utf8))
< 
<     if use_utf8:
<         serialized_alphabet = UTF8Alphabet().serialize()
<     else:
<         if not alphabet_path:
<             raise RuntimeError("No --alphabet path specified, can't continue.")
<         serialized_alphabet = Alphabet(alphabet_path).serialize()
---
> 
>     if not alphabet_path:
>         raise RuntimeError("No --alphabet path specified, can't continue.")
>     serialized_alphabet = Alphabet(alphabet_path).serialize()
53d65
<     scorer.set_utf8_mode(use_utf8)
55a68,73
>     # TODO: Why is this not working?
>     #err = scorer.load_lm(lm_path)
>     #if err != ds_ctcdecoder.DS_ERR_SCORER_NO_TRIE:
>     #    print('Error loading language model file: 0x{:X}.'.format(err))
>     #    print('See the error codes section in https://deepspeech.readthedocs.io for a description.')
>     #    sys.exit(1)
59,147c77
<     print("Package created in {}".format(package_path))
< 
< 
< class Tristate(object):
<     def __init__(self, value=None):
<         if any(value is v for v in (True, False, None)):
<             self.value = value
<         else:
<             raise ValueError("Tristate value must be True, False, or None")
< 
<     def __eq__(self, other):
<         return (
<             self.value is other.value
<             if isinstance(other, Tristate)
<             else self.value is other
<         )
< 
<     def __ne__(self, other):
<         return not self == other
< 
<     def __bool__(self):
<         raise TypeError("Tristate object may not be used as a Boolean")
< 
<     def __str__(self):
<         return str(self.value)
< 
<     def __repr__(self):
<         return "Tristate(%s)" % self.value
< 
< 
< def main():
<     parser = argparse.ArgumentParser(
<         description="Generate an external scorer package for DeepSpeech."
<     )
<     parser.add_argument(
<         "--alphabet",
<         help="Path of alphabet file to use for vocabulary construction. Words with characters not in the alphabet will not be included in the vocabulary. Optional if using UTF-8 mode.",
<     )
<     parser.add_argument(
<         "--lm",
<         required=True,
<         help="Path of KenLM binary LM file. Must be built without including the vocabulary (use the -v flag). See generate_lm.py for how to create a binary LM.",
<     )
<     parser.add_argument(
<         "--vocab",
<         required=True,
<         help="Path of vocabulary file. Must contain words separated by whitespace.",
<     )
<     parser.add_argument("--package", required=True, help="Path to save scorer package.")
<     parser.add_argument(
<         "--default_alpha",
<         type=float,
<         required=True,
<         help="Default value of alpha hyperparameter.",
<     )
<     parser.add_argument(
<         "--default_beta",
<         type=float,
<         required=True,
<         help="Default value of beta hyperparameter.",
<     )
<     parser.add_argument(
<         "--force_utf8",
<         type=str,
<         default="",
<         help="Boolean flag, force set or unset UTF-8 mode in the scorer package. If not set, infers from the vocabulary. See <https://github.com/mozilla/DeepSpeech/blob/master/doc/Decoder.rst#utf-8-mode> for further explanation",
<     )
<     args = parser.parse_args()
< 
<     if args.force_utf8 in ("True", "1", "true", "yes", "y"):
<         force_utf8 = Tristate(True)
<     elif args.force_utf8 in ("False", "0", "false", "no", "n"):
<         force_utf8 = Tristate(False)
<     else:
<         force_utf8 = Tristate(None)
< 
<     create_bundle(
<         args.alphabet,
<         args.lm,
<         args.vocab,
<         args.package,
<         force_utf8,
<         args.default_alpha,
<         args.default_beta,
<     )
< 
< 
< if __name__ == "__main__":
<     main()
---
>     print("Package created in {}".format(package_path))
\ No newline at end of file
